#### 数据在存储器中的存放方式

如，12345678H在计算机中的存放方式。

大端方式：从高字节到低字节。认为第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）

![image-20200920222704511](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920222704511.png)

小端方式：从低字节到高字节。它认为第一个字节是最低位字节（按照从低地址到高地址的顺序存放据的低位字节到高位字节）。

![image-20200920222727890](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920222727890.png)

---

# 1、指令格式

## 1.1、指令的基本格式

| 操作码 | 地址码 |
| ------ | ------ |
| OP     | A      |

### 1.零地址指令

不需要操作数的指令，如空操作、停机、关中断指令

对战计算机中的零地址运算指令

### 2.一地址指令

| OP   | $A_1$ |
| ---- | ----- |
|      |       |

(Acc)OP($A_1$)——>Acc

(PC)+1——>PC

### 3.二地址指令

| OP   | $A_1$ | $A_2$ |
| ---- | ----- | ----- |
|      |       |       |

($A_1$)OP($A_2$)——>$A_2$

(PCC)+1——>PCC

### 4.三地址指令

| OP   | $A_1$ | $A_2$ | $A_3$ |
| ---- | ----- | ----- | ----- |
|      |       |       |       |

($A_1$)OP($A_2$)——>$A_3$

(PCC)+1——>PCC

### 5.四地址指令

| OP   | $A_1$ | $A_2$ | $A_3$ | $A_4$ |
| ---- | ----- | ----- | ----- | ----- |
|      |       |       |       |       |

($A_1$)OP($A_2$)——>$A_3$

$A_4$=下一条要将要执行的指令

### 特点

![image-20200920154103124](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920154103124.png)

## 1.2、定长操作码指令格式

优点：计算机的硬件设计简单，指令译码和执行速度快;

缺点：当指令数量增多、指令字单独为操作码划分出固定的多位后，留给表示操作数 
地址的位数就会严重不足；

适用环境：适用于字长较长的计算机系统，如32位或32位以上。

## 1.3、不定长操作码指令格式

优 点 ：在比较短的指令字中，既能表示出比较多的指令条数又能尽量满足操作数地址
的要求；
缺点：计算机的硬件设计复杂，指令译码和执行速度较慢；
适用环境：适用于字长较短的计算抑系统，如16位或16位以下。

![image-20200920155955767](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920155955767.png)

----

# 2、指令的寻址方式

## 2.1、数据寻址和指令寻址

### 1.指令寻址

顺序寻址

跳跃寻址

### 2.数据寻址

寻址特征：标识采用什么样的寻址方式能够找到操作数所在的地址。

有效地址：操作数的真实地址。

![image-20200920165406366](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165406366.png)

## 2.2、常见数据寻址方式

### 1.立即寻址

形式地址A就是操作数，这个数据直接参与操作码指定的运算

\#：立即寻址的特征，在译码过程中，如果发现寻址特征位是#，表示后面的操作数是立即数。立即数可以是正数，也可以是负数，用**补码**进行表示。

![image-20200920165449765](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165449765.png)

**优点**:只需取出指令，便可立即获得操作数。只需在访问时访问一次存储器，执行时不需要再访问存储器

**缺点**：A的位数限制了A的取值范围

用途：立即寻址方式主要用于对某寄存器或内存单元赋值

### 2.直接寻址

有效地址 = 形式地址

EA=A

EA是有效地址。A给出的就是操作数所在的内存单元的地址，由形式地址直接给出

![image-20200920165553881](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165553881.png)

**优点：**寻找操作很简单，因为直接就给出了操作数的有效地址，不需要经过变换

**缺点：**操作数的地址由A决定，A的位数比较小，所以地址范围小

### 3.隐含寻址（了解即可）

把寻址方式隐藏到操作码中，或者是参与运算某一个数据由操作码直接给出

![image-20200920165709019](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165709019.png)

### 4.间接寻址（非常重要）

指操作数的地址保存在某一个内存单元中，指令当中出现的是这个内存单元的地址，有效地址在给定的内存单元中进行保存

EA=(A) 有效地址由形式地址间接提供

**一次间址**

![image-20200920165804956](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165804956.png)

**多次间址**

![image-20200920165821391](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165821391.png)

**优点：**便于子程序返回和查表

**缺点：**访问存储器的次数，一次间接寻址需要访问两次（一次取操作数有效地址，一次取操作数），N次间接寻址需要访问N+1次（前面N次访问操作数的有效地址，最后一次取操作数）

**用途：**寻找中断服务程序入口

### 5.寄存器寻址

指令的有效地址就是寄存器的编号

EA=$R_i$

![image-20200920165857003](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165857003.png)

**优点：**

- 由于操作数在寄存器中，因此指令在执行阶段不需要访存，减少了执行时间
- **减少了指令字的长度**

### 6.寄存器间接寻址

操作数保存在内存单元中的，操作数的地址保存在寄存器中

EA=($R_i$)

![image-20200920165933405](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920165933405.png)

**优点：**便于编制循环程序

**缺点：**对于直接和间接寻址来说不算缺点，对于寄存器来说要多访问一次存储器。

### 7.基址寻址

**在CPU中设置专用的寄存器作为基址寄存器**

参加操作的操作数的有效地址，是基址寄存器中保存的内容加上形式地址

EA=(BR)+A  BR为基址寄存器

![image-20200920170019158](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920170019158.png)

**特点**

- 可扩大寻址范围（基址寄存器的位数大于形式地址的位数 )
- 用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计；

**说明**： 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统来确定。

### 8.变址寻址

变址寄存器内容加上形式地址内容等于有效地址

EA=(IX)+A	IX为变址寄存器（专用）；通用寄存器也可作为变址寄存器

![image-20200920170128275](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920170128275.png)

**特点：**

- 变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；
- 在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任意数据的地址。特别适合编制循环程序。

### 9.相对寻址

相对寻址，相对的是当前的PC值，所以有效地址等于PC值加上形式地址，表示如下：

EA=(PC)+A

A是相当于当前指令的位置，可正可负，补码

![image-20200920170237631](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920170237631.png)

**用途：**

- 用于转移指令
- 便于编制浮动程序

### 10.堆栈寻址

**硬堆栈：** 在堆栈型的计算机中，一般都采用硬堆栈方式，也就是说由**多个寄存器作为栈顶**，栈底部分在内存中。进行操作的话，如加法操作，将两个操作数均来自于栈顶，操作完成后将操作结果保存在栈顶。
**软堆栈：** 指定的一段**内存**空间。



----

# 3、CISC和RISC的基本概念

## 1.RISC的主要特点总结（精简指令集）

Reduced Instruction Set Computer

#### 主要特征：

（1）指令集比较小，只选择使用频率较高的简单指令，复杂指令功能由简单指令组合实现。使得机器的控制设计简单。

（2）指令长度固定，指令格式种类少，寻址方式少。译码简单，甚至操作码位置固定，操作数位置固定，在译码时候可以取操作数，可以对操作数进行读操作。提供指令速度。

（3）只有 LOAD，STORE指令访存，其他指令都不能访存，其他指令的传输操作或者是算数运算，逻辑运算操作，只能在寄存器和寄存器之间执行，并且结果保存在寄存器中。这样CPU中有比较多的通用寄存器支持这些操作。

（4）指令比较简单，指令之间的关系简单，所以精简指令集的计算机都是采用流水线的方式来做的，而且特别关注提高流水线的效率，在一个时钟周期内完成一条指令。

（5）为了提高速度，所有的精简指令集的指令都是采用组合逻辑的方式，也就是用硬联方式实现控制器，使其速度更快。

## 2.CISC的主要特点总结（复杂指令集）

#### 主要特征：

（1）系统指令复杂庞大，各种指令使用频度相差大。

（2）指令的长度不固定，指令格式多种多样，寻址方式也非常多，导致译码过程非常复杂，CPU硬件部分设计复杂。

（3）访存指令不受限制。

（4）CPU中设有专用寄存器

（5）大多数指令需要多个时钟周期完成，因为指令比较复杂，如果指令都采用硬联方式实现，硬件系统会非常庞大。

（6）在CPU设计时候，采用微程序控制器，指令被分成若干个微指令，微指令按顺序执行完成这条指令要求的功能，微指令组成的微程序保存在控制存储器中，执行指令的时候需要多次访问控制存储器，速度慢。

## 3.CISC和RISC的比较

![image-20200920220606325](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200920220606325.png)

---

# 4、错题

- 如果机器字长和存储字长一样的话，取指周期等于机器周期
- 取指周期是指令周期的第一个阶段，也称取指令阶段。即控制单元执行程序的周期内，从存储单元取出所要执行的指令的过程。
- 指令周期是取出一条指令并执行这条指令的时间。一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间。
- 指令寄存器的位数取决于**指令字长**
- [ 直接寻址的 ]无条件转移指令的功能是将指令中的地址码送入PC
- 最适合按下标顺序访问一维数组的是**变址寻址**
- 