# 1、内存管理基础

## 1.1、内存管理概述

内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。

### 1.内存管理器的功能

- 内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。
- 地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。
- 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。
- 存储保护：保证各道作业在各自的存储空间内运行，互不干扰。

### 2.应用程序的编译、链接与接入

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-1406301T554425.jpg)

- 名地址或符号地址：数据的存放地址
- 名空间或符号空间：源程序的地址空间
- 相对地址或虚拟地址：目标代码地址

#### 程序链接的三种方式：

1. 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。
2. 装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式。
3. 运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。

#### 程序装入的三种方式：

1. 绝对装入：在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。
2. 可重定位装入：在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的,此时应釆用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位，如图3-2(a) 所示。
3. 动态运行装入：装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。

静态重定位特点：

`容易实现`

静态重定位缺点：

`要求分配一个连续的存储区，空间不够整个程序就不能运行`

`程序执行期间不能移动，不能再申请空间，难做到数据共享`

动态重定位特点：

`可以将程序分配到不连续的存储区`

动态定位的缺点：

`需要硬件支持，实现存储管理的软件算法比较复杂`

### 3.逻辑地址和物理地址

- 逻辑地址

`由程序产生的与段相关（与页无关，用户只看得到段）的偏移地址部分`

- 物理地址

`是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。`

### 4.内存保护

防止一个作业有意或无意地破坏操作系统或其他作业

#### 界限寄存器方法

- 上下界寄存器方法
- 基址和限长寄存器方法

#### 存储保护键方法

## 1.2、覆盖与交换

### 1.覆盖技术

主要用在早期的操作系统中，对程序员要求较高。

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

### 2.交换技术

把处于等待状态（或在CPU调度原则下被剥夺运行权利） 的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。

## 1.3、连续分配管理方式

内部碎片：已经分配给作业但不能被利用的内存空间

外部碎片：系统中还没有分配给作业，但由于碎片太小无法分配给申请内存空间的新城的存储块。

### 1.单一连续分配

内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。

优点：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。

缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。

### 2.固定分区分配

最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。

两种分配方法：

- 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。
- 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。

### 3.动态分区分配

动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

#### 动态分区的数据结构

- 空闲分区表
- 空闲分区链

#### 分区分配算法

##### 首次适应算法FF

空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。

优点：无内部碎片

缺点：增加查找空闲分区的开销

##### 下次适应算法NF

又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。

优点：空闲分区更加均匀，减少查找空闲分区的开销

缺点：缺乏大的空闲分区

##### 最佳适应算法BF

空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区.

优点：保留大的分区

缺点：产生很多难以利用的碎片空间

##### 最差适应算法WF

又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。

优点：剩下的空闲分区比较大

缺点：大作业来临时，存储空间的申请得不到满足

#### 分区的回收



#### 分区分配的动态管理

拼接技术：

动态重定位分区分配技术：

#### 动态分区的优缺点

优点：

1. 实现多道程序共用内存
2. 管理方案相对简单、不需要更多开销
3. 实现存储保护的手段比较简单

缺点：

1. 主存利用不够充分，存在外部碎片
2. 无法实现多进程共享存储器信息
3. 无法实现贮存的扩充，进程地址空间受实际存储空间的限制

![image-20200913011812704](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200913011812704.png)

## 1.4、非连续分配管理方式

### 1.基本分页存储管理方式

如果允许将一个作业存放到许多不相邻接的分区中，那么就可以避免拼接，从而有效的解决外部碎片问题。

#### 分页原理

页或页面：用户作业的地址空间被划分成若干个大小相等的区域

块或物理块：主存的存储空间也分成与页面大小相等的区域

为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F10031342c.png)

0~11是页内位移地址，大小为$2^{12}B$=$4KB$

12~31是页号，一个进程最多的页数为$2^{20}=1M$

`假设逻辑地址为A，页面大小为L，`

`则页号P=(int)(A/L)，偏移量W=A%L`

#### 页表

为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。

在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1003A14D.jpg)

#### 基本地址变换机构

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1004005H3.jpg)

1. 计算页号P(P=A/L)和页内偏移量W (W=A%L)。
2. 比较页号P和页表长度M，若P >= M，则产生越界中断，否则继续执行。
3. 页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。
4. 计算E=b*L+W，用得到的物理地址E去访问内存。

#### 具有快表的地址变换机构

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F100444V53.jpg)

- CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。
- 如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。
- 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

#### 两级页表和多级页表

##### 页表大小计算

页表长度M是由页号的位数决定的

##### 两级页表

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1005205M0.jpg)

##### 多级页表

主要缺点：要多次访问内存，每次地址变换都很浪费时间

#### 页的共享与保护

在分页存储管理系统，实现共享的方法：使共享用户地址空间中的页指向相同的物理块。

#### 基本分页存储管理方式的优缺点

优点：

1. 内存利用率高
2. 实现了离散分配
3. 便于存储访问控制
4. 无外部碎片

缺点：

1. 需要硬件支持（尤其使快表）
2. 内存访问效率下降
3. 共享困难
4. 内部碎片

### 2.基本分段存储管理方式

按逻辑关系分段，每段要有自己的名字，以便根据名字访问响应的程序段或者数据段。

相较于分页存储管理方式的优点：

- 方便编程
- 信息共享
- 信息保护

#### 分段存储原理

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1005Z3T5.png)

段内位移占16位所以最大段长位为$64KB$

一个作业最多有$2^{16}=65536$段

#### 段表及地址变换过程

<center>段表项的结构</center>

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F10101563W.png)



<center>利用段表实现地址映射</center>

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1010615163.jpg)



![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F1011015B6.jpg)

从逻辑地址A到物理地址E之间的地址变换过程如下：

- 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。
- 比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。
- 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>=C，则产生越界中断，否则继续执行。
- 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。

#### 段的共享与保护

程序被分为代码区和数据区

纯代码或可冲入代码：不能修改的代码

纯代码和不能修改的数据是可以共享的。

分段管理的保护：

1. 地址越界保护
2. 访问控制保护

#### 基本分段存储管理方式优缺点

优点：

1. 便于程序模块化处理和处理变换的数据结构
2. 便于动态链接饥和共享
3. 无内部碎片

缺点：

1. 与分页类似，需要硬件支持
2. 为满足分段的动态增长和减少外部碎片，要采用拼接技术
3. 分段的最大尺寸收到贮存可用空间的限制
4. 有外部碎片

#### 分段与分页的区别



| 分页                                         | 分段                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| 信息的物理单位                               | 信息的逻辑单位                                               |
| 分页的目的是系统管理所需，为了提高内存利用率 | 分段的目的是为了更好地满足用户的需要                         |
| 页的大小固定且由系统规定                     | 段的长度不定，不同的段有不同的段长，是由用户编写的程序决定的 |
| 有内部碎片无外部碎片                         | 无内部碎片有外部碎片                                         |

### 3.基本段页式存储管理方式

<center>段页式存储管理系统的数据结构</center>

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F101195Da.png)

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F10123342B.jpg)



# 2、虚拟内存管理

## 2.1、虚拟内存的基本概念

### 1.虚拟内存的引入原因

引入了一种能够让作业部分装入就可以运行的存储管理技术，及虚拟内存管理技术。

### 2.局部性原理

快表、 页高速缓存以及虚拟内存技术从广义上讲，都是属于高速缓存技术。这个技术所依赖的原理就是局部性原理。局部性原理既适用于程序结构，也适用于数据结构。

#### 时间局部性

如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。

#### 空间局部性

一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

### 3.虚拟内存的定义及特征

从逻辑上扩充内存容量的存储器系统称为虚拟存储器。系统知识提供了部分装入、请求调入和置换功能。

虚拟内存的意义：让程序存在的地址空间与运行时的存储空间分开，程序员可以完全不考虑实际内存的大小，而在地址空间内编写程序。

#### 离散性

程序在内存中离散存储（不是虚拟内存独有的特征，基本分页和分段也有）。

#### 多次性

是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。

#### 对换性

是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。

#### 虚拟性

是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。

### 4.实现虚拟内存的硬件和软件支持

需要有一定的物理基础：

- 一定容量的内存和外存。
- 页表机制（或段表机制），作为主要的数据结构。
- 中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。
- 地址变换机构，逻辑地址到物理地址的变换。

## 2.2、请求分页存储管理方式

先将程序部分载入内存运行，当需要其他部分时再调入内存。

### 1.请求分页原理

在分页存储管理系统的基础上，增加请求调页功能、页面置换功能所形成的一种虚拟存储系统。

$请求分页=基本分页+请求调页功能+页面置换功能$

### 2.页表结构

<center>页表项</center>

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F10202531Y.png)

各字段的作用如下：

- 状态位P：用于指示该页是否已调入内存，供程序访问时参考。
- 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。
- 修改位M：标识该页在调入内存后是否被修改过。
- 外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。

### 3.缺页中断与地址变换



![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140F102004L08.jpg)

缺页中断的概念：系统发现要访问的页不在内存中。

缺页中断是比较特殊的中断：

- 在指令的执行期间产生和处理缺页中断。一般是在指令执行完毕后检查是否产生中断
- 一条指令可能发生多个缺页中断。

### 4.请求分页管理方式的优缺点

优点：

1. 可以离散存储程序，降低了碎片数量
2. 提供虚拟存储器，提高了主存利用率，有利于多道程序运行，方便用户

缺点：

1. 必须要有硬件支持
2. 有些情况下会发生抖动现象
3. 程序最后一页仍然存在未被利用的内存空间

## 2.3、页面置换算法

用来选择换出页面的算法

### 1.最佳置换算法OPT

所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。

### 2.先进先出算法FIFO

优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。

#### Belady异常

FIFO算法还会产生<u>当所分配的物理块数增大而页故障数不减反增</u>的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。

### 3.最近最少使用LRU算法

选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。

LRU最接近OPT

### 4.时钟置换算法CLOCK

简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。

CLOCK算法比LRU少了很多硬件支持，但是比FIFO需要的硬件多。

### 5.改进型时钟算法

CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：

1. 最近未被访问，也未被修改(访问位=0,修改位=0)。
2. 最近被访问，但未被修改(访问位=1,修改位=0)。
3. 最近未被访问，但被修改(访问位=0,修改位=1)。
4. 最近被访问，被修改(访问位=1, 修改位=1)。



算法执行如下操作步骤：

1. 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。
2. 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。
3. 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。

### 6.其他页面置换算法

#### 最不常用置换算法LFU

要求为每一个页面设置访问计数器，每当页面被访问时，该页的访问计数器加1。

#### 页面缓冲算法PBA

是对FIOFO的发展，通过建立置换页面的缓冲，找回刚被直换的页面，从而减少系统的I/O消耗。

## 2.4、工作集与页面分配策略

抖动现象：在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。

### 1.工作集理论

#### 工作集

是最近n次内存访问的页面的集合，数字n称为工作集窗口	

工作集模型的原理：让操作系统监视各个进程的工作集，主要是监视各个工作集的大小。

### 2.页面分配策略

#### 固定分配局部置换

它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。

#### 可变分配全局置换

这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。

#### 可变分配局部置换

。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

### 3.页面调入策略

#### 请求调页策略

进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。

容易产生抖动现象

#### 预调页策略

根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。

### 4.从何处调入页面

外村分为两部分：文件区和对换区

#### 文件区

存放文件的

#### 对换区

存放对换页面的

#### 系统拥有足够的对换区空间

可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。

#### 系统缺少足够的对换区空间

凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。

#### UNIX方式

与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。

## 2.5、抖动现象与缺页率

### 1.Belady异常

FIFO置换算法的缺页率可能随着所分配的物理块数目增加而增加。

原因是：FIFO的置换特征与进程访问内存的动态特征矛盾，即被置换的页面并不是进程不会访问的。

FIFO可能出现Belady异常但是LRU和OPT永远不会出现Belady异常，被归类为堆栈 算法的页面置换算法也不会出现Belady异常。

### 2.抖动现象

在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。

### 3.缺页率

缺页率是衡量页面置换算法的重要指标。

设需要访问A次页面，所需页调入内存的次数为F

则缺页率$f=F/A$,命中率为$1-f$

## 2.6、请求分段存储管理系统



# 3、内存管理方式之间的队对比与一些计算方法

## 3.1、内存管理方式之间的比较

## 3.2、内存管理计算中地址的处理

## 3.3、基本分页管理方式中有效访问时间的计算

## 3.4、请求分页管理方式中有效访问时间的计算



# 4、错题

- 二分法搜索因为不具有局部性，不适合按需调页的虚拟内存管理策略
- 矢量运算就是数组运算，具有局部性
- 缺页次数的上限时引用串的长度，下限时不同序号的个数
- 目标地址对应的地址空间是逻辑地址空间
- 外层页表是页表的页表，为了不连续的页表而建立的，需要一个外层页表寄存器即可实现地址变换
- 虚拟内存只能基于非连续分配技术