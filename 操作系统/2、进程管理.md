# 1、进程与线程

## 1.1、进程的引入

> 在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位。
>

### **前驱图**

> > **前趋关系“→ ”的形式化描述**：→ ={<Pi, Pj> | Pi must complete before Pj may start} 
>>
> > <Pi, Pj>∈→，可写成Pi→Pj，表示在Pj开始执行之前Pi必须完成。此时称 Pi 是 Pj 的直接前驱，而称 Pj 是 Pi 的直接后继。在前驱图中把没有前驱的结点称为初始结点（Initial Node），把没有后继的结点称为终止结点 （Final Node）。此外，每个结点还具有一个重量（Weight），用于表示该结点所含有的程序量或程序的执行时间。
>

### 程序的顺序执行

> > 特征：
>>
> > 1. 顺序性。每一个操作必须在下一个操作开始之前结束
>> 2. 封闭性。资源的状态只有本程序才能改变
> > 3. 可再现性。重复执行，可以获得相同的结果
> 

### 程序的并发执行

> > 若干个程序，一个程序尚未结束，另一个程序的执行已经开始。
>>
> > 特征：
>>
> > 1. 间断性。程序并发时，它们共享系统中的资源或者为完成同一个任务相互合作，致使在并发当中形 成某种制约关系（比如刚刚举的例子S4中的S3没有算出，S4的执行必须等待），所以并发进程具有“执行 - 暂停 - 执行”间断性活动。因此也叫**制约性**。
> > 2. 失去封闭性。当处理器被某程序占用时，其他程序必须等待。
> > 3. 不可再现性。
>

### **程序并发执行的条件**

 > Bersnstein条件
 >
 > 并发进程的无关系是进程执行与时间无关的一个充要条件
 > 设 `R(pi)={a1,a2,…an}`，表示程序 `pi` 在执行期间引用的变量集，称读集；
 >
 > `W(pi)={b1,b2,…bm}`，表示程序 pi 在执行期间改变的变量集，称为写集；
 >
 > 若两个程序能满足 Bernstein 条件、即变量集交集之和为空集：
 >  `R(p1)&W(p2) U R(p2)&W(p1) U W(p1)&W(p2)={ }`
 >
 >   >  则并发进程的执行与时间无关。

## 1.2、进程的定义及描述



### 进程实质的定义

> 1. 进程是程序在处理器上的一次执行过程
> > 2. 进程是可以和别的进程并行执行的计算
> > 3. 进程是程序在一个数据几何上的运行过程，是系统进行资源分配和调度的一个独立单位
> > 4. 进程可定义为一个数据结构及能在其上进行操作的一个程序
> > 5. 进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动



### **进程的特征**

> > 1. 动态性
> > 2. 并发性
> > 3. 独立性
> > 4. 异步性
> > 5. 结构特征。为了描述和记录进程的运动变化过程，并使其能正确运行，应为每个进程配置一个进程控制块PCB（Process Control Block）。每个进程=程序段+数据段+进程控制块PCB
> >
> > **进程和程序的关系**：
> >
> > 1. 进程是动态的，程序是静止的
> > 2. 进程是暂时的，程序是永久的
> > 3. 进程与程序的组成不同
> > 4. 通过执行，一个程序可以产生多个不同的进程；通过调用关系，一个进程可以执行多个程序。进程可创建其他进程，程序不能形成新的程序。
> >
> > **进程和作业的区别**：进程是已提交完毕的作业的执行过程，是资源分配的基本单位
> >
> > 1. 作业是用户向计算机提交任务的任务实体
> > 2. 一个作业可由多个进程组成，且必须至少由一个进程组成，但一个进程不能构成多个作业
> > 3. 作业的概念主要用在批处理操作系统中。像UNIX分时系统没有作业的概念；而进程的概念在几乎所有的多道程序系统中
> >
> > **进程的组成**：
> >
> > 1. PCB。
> > 2. 程序段
> > 3. 数据段
> >
> > PCB是进程存在的唯一标志。
> >
> > **PCB包含的内容**：
> >
> > 1. 进程标识符PID
> > 2. 进程当前状态
> > 3. 进程队列指针
> > 4. 程序和数据地址
> > 5. 进程优先级
> > 6. CPU现场保护区。当进程由于某种原因释放处理器，CPU现场信息（如指令计数器、状态寄存器、通用寄存器等）被保护在PCB的该区域中，以便进程重新获得处理起后继续执行
> > 7. 通信信息
> > 8. 家族联系
> > 9. 占有资源清单
> >
> > **PCB为什么是进程存在的唯一标志**
> >
> > > PCB是为了保证程序的并发执行。
> > >
> > > 创建进程实质上就是创建进程的PCB，撤销进程，实质上就是撤销进程的PCB。
> > >
> > > 原因：系统总是通过PCB对进程进行控制的，亦即系统是根据进程的PCB感知该进程的存在的，所以，PCB是进程存在的唯一标志。

## 1.3、进程的状态与转换

### 进程的5种基本状态

> 1. 就绪状态。进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行
> 2. 执行状态。进程处于就绪状态被调度后，进程进入执行状态
> 3. 阻塞状态。正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用
> 4. 创建状态。进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态
> 5. 结束状态。进程结束，或出现错误，或被系统终止，进入终止状态。无法再执3行

### 进程状态的相互转换

> <img src="https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200910175238294.png" alt="image-20200910175238294" style="zoom:67%;" />
>
> > 结论：
> >
> > 1. 进程不能从阻塞变成执行，不能从就绪到阻塞。
> > 2. 进程状态是唯一的。
> > 3. 执行只能从就绪状态转换

## 1.4、进程的控制

### 1.进程的创建

#### 进程前趋图

> > ![image-20200910175818518](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200910175818518.png)
> >
> > 进程前趋图又称为进程树或进程家族树，是描述进程家族关系的一颗有向树。

#### 创建原语

> - 用户登录
> - 作业调度
> - 请求服务
> - 先向系统申请一个空闲PCB，并指定唯一的进程标识符PID
> - 为新进程分配必要的资源
> - 新进程的PCB初始化。为新进程的PCB填入进程名、家族信息、程序数据地址、优先级等信息
> - 将新进程的PCB插入到就绪队列

### 2.进程的撤销

> - 先从PCB集合中找到被撤销进程的PCB
> - 若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标志，以便进程撤销后将处理器分配给其他进程
> - 对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程撤销
> - 回收被撤销进程所占用的资源，或者归还给父进程，或者归还给系统。<u>最后回收他的PCB</u>

### 3.进程的阻塞与唤醒

> 阻塞原语（P原语）的功能是将进程由执行状态转为阻塞状态，唤醒原语（V原语）的功能是将阻塞状态转换为就绪状态。
>
> 阻塞原语的主要操作：
>
> - 首先停止当前进程的运行
> - 保存该进程的CPU现场
> - 停止运行该进程
> - 转到进程调度程序，从就绪队列中选择一个新的进程投入运行
>
> 唤醒原语的主要操作：
>
> - 将被唤醒的进程从相应的等待队列中移出
> - 将状态改为就绪并插入相应的就绪队列

### 4.进程切换

> 过程：
>
> - 保存处理及上下文，包括程序计数器和其他寄存器
> - 更新PCB信息
> - 把进程的PCB移入相应队列，如就绪】某事件的阻塞队列等
> - 选择另一个进程执行，更新其PCB
> - 更新内存管理的数据结构
> - 恢复处理器上下文

## 1.5、线程

> 线程的引入提高了程序并发执行的程度

### 1.线程的概念

#### 线程的引入

> 进程的两个基本属性：
>
> 1. 进程是一个拥有资源的独立单元
> 2. 进程同时又是一个可以被处理器独立调度和分配的单元
>
> 线程完成第二个基本属性，进程只完成第一个基本属性的任务

#### 线程的定义

> - 线程是进程内的一个执行单元，但比进程更小
> - 线程是进程内的一个可调度实体
> - 线程是程序（或进程）中相对独立的一个控制流序列
> - 线程本身不能单独运行，只能包含在进程中，只能在进程中执行 
>
> 线程的定义：线程是进程内一个相对独立的、可调度的执行单元。
>
> 多线程是指一个进程中有多个线程，这些线程共享该进程资源。

#### 线程的实现

> 内核级线程：依赖于内核，由操作系统内核完成创建和撤销工作的线程。
>
> 用户级线程：不依赖于操作系统核心，由应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制的线程。

### 2.线程与进程的比较

> - 调度。线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一个进程中切换线程，不会引起线程切换；在不同的进程中切换线程，会引起进程的切换。
> - 拥有资源。进程是拥有资源的基本单位，线程不拥有资源
> - 并发性。进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行
> - 系统开销。线程切换时，涉及整个当前进程CPU环境的保存及新调度到进程的CPU环境配置；线程切换时，只需保存和设置少量寄存器内容，因此开销很小。

### 3.多线程模型

> 多对一模型：
>
> >  将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。
> >
> > 此模式中，用户级线程对操作系统不可见（即透明）。
> >
> > `优点：线程管理是在用户空间进行的，因而效率比较高。`
> >
> > `缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。`
>
> 一对一模型：
>
> > 将每个用户级线程映射到一个内核级线程。
> >
> > `优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。`
> >
> > `缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。`
>
> 多对多模型：
>
> > 将 n 个用户级线程映射到 m 个内核级线程上，要求 m <= n。
> >
> > 特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。

## 1.6、进程通信

> 进程之间的信息交换

### 1.共享存储器系统

> 为了传输打两数据，在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写来实现通信。

### 2.消息传递系统

> 进程间一消息为单位交换数据，用户直接利用系统提供的一组通信命令（原语）来实现通信。
>
> - 直接通信方式。
> - 间接通信方式

### 3.管道通信系统

> 管道适用于连接都进程和写进程以实现他们之间通信的共享文件。
>
> 管道是一个共享文件，不能单纯地从字面上仅将管道理解为一个传输通道。



# 2、处理器调度

## 2.1、处理器的三级调度

![处理器的三级调度与进程调度算法](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/v2-4881bc8547570a18548454f919cd8c80_1440w.jpg)



### 1.高级调度（作业调度）

> 又称高级调度，.其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。
>
> 多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。

### 2.中级调度

> 又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。

### 3.低级调度（进程调度）

> 又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

高级调度与低级调度的区别

- 作业调度的结果是为作业创建进程，进程调度的结果时进程被执行
- 作业调度次数少，进程调度频率高
- 有的系统可以不设置作业调度，但进程调度必须有

## 2.2、调度的基本原则

### 1.CPU利用率

> CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。

### 2.系统吞吐量

> 表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。

### 3.响应时间

> 是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。

### 4.周转时间

> 是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。
>
> > `周转时间 = 作业完成时间 - 作业提交时间`
> >
> > `平均周转时间是指多个作业周转时间的平均值：`
> >
> > `平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n`
> >
> > `带权周转时间是指作业周转时间与作业实际运行时间的比值：`
> >
> > 平均带权周转时间是指多个作业带权周转时间的平均值：
> >
> > 平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n

## 2.3、进程调度

### 1.进程调度的功能

> - 记录系统中所有进程的有关情况以及状态特征
> - 选择获得处理器的进程
> - 处理器分配

### 2.引起进程调度的原因

- 当前进程运行结束
- 当前运行进程因某种原因从运行状态进入阻塞状态
- 执行完系统调用等系统程序后返回用户进程
- 在采用抢占调度方式的系统中，一个具有更高优先级的进程要求使用处理器 

### 3.不能进行进程调度的情况

- 处理中断的过程中
- 在操作系统内核程序临界区
- 其他需要完全屏蔽中断的原子操作过程

### 4.进程调度的方式

> - 抢占方式
> - 非抢占方式

## 2.4、常见调度算法

### 1.先来先服务调度算法（作业调度、进程调度）FCFS

> ### 优点：
>
> 1. 有利于长作业（进程）
> 2. 有利于CPU繁忙型的作业（进程）
>
> ### 缺点：
>
> 1. 不利于短作业（进程）
> 2. 不利于I/O繁忙型作业（进程）

### 2.短作业优先算法调度算法（作业调度、进程调度）SJF

> 短进程优先调度算法是从就绪队列中选出一个估计运行时间最短的进程，再将处理机分配给它，直到执行完成。而其他进程一般不抢先正在执行的进程。
>
> ### 优点：
>
> 有效的降低了进程的平均等待时间，提高了系统高度吞吐量。
>
> ### 缺点：
>
> 1. 算法对长作业（进程）不利（长作业（进程）长期不被调度）。
> 2. 未考虑进程的紧迫程度。
> 3. 由于是估计运行时间而定，而这个时间是由用户所提供的，所以该算法不一定能真正做到短作业优先调度

### 3.优先级调度算法（作业调度、进程调度）

> **该算法的核心问题是**如何确定进程的优先级
>
> ### 静态优先级确定的依据
>
> - 按进程类确定
> - 按作业的资源要求确定
> - 按用户类型和要求确定
> - 根据进程占有CPU时间的长短来决定
> - 根据就绪进程等待CPU时间来决定
>
> ### 调度方式的不同
>
> - ##### 非抢占式优先权算法,如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程。
>
>   这种调度算法主要被用于批处理系统中。
>
> - ##### 抢占式优先权算法,系统在队列中把一个优先权最高的进程执行，但是如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程执行。
>
>   这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。

### 4.时间片轮换调度算法（进程调度）

> ### 简介
>
> 为了保证能及时相应用户的请求，所以我们采用了基于时间片的轮转调度算法，它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间的执行。
>
> ### 算法缺点
>
> 时间片的大小设置很关键，如果执行时间（时间片）选择的不好，将对性能产生很大的影响，例如如果选择了小的时间片，那么会对短进程将很有利，很快被执行完成，但是会频繁的发生中断，增加系统的开销，但是如果选择的执行时间过长，此种算法又和先来先服务算法效果一样了。
>
> ### 确定执行时间
>
> 1. 系统的处理能力，
> 2. 此就绪时队列中的进程数目。
> 3. 系统对相应时间的要求

### 5.高响应比优先调度算法（作业调度）

> 综合了FCFS和SJF的特点。
>
> ### 响应比
>
> 响应比=作业响应时间/估计运行时间
>
> 即 相应比=（作业等待时间+估计运行时间）/估计运行时间

### 6.多级队列调度算法（进程调度）

> 基本思想是根据进程的性质或类型，将就绪队列划分为若干个独立的队列，每个进程固定地分属于一个队列，每个队列采用一种调度算法。

### 7.多级反馈队列调度算法（进程调度）

> 是时间片乱换调度算法和优先级调度算法的综合与发展



# 3、同步与互斥

## 3.1、进程同步的基本概念

### 两种形式的制约关系

#### 1. 同步

**同步**，又称**直接制约关系**，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。

例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。我们可以使用信号量进行同步：

#### 2. 互斥

**互斥**，又称**间接制约关系**，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。

例如，打印机就是一种临界资源，而访问打印机的代码片段称为临界区，故每次只允许一个线程进入临界区。—— 我们同样可以使用信号量解决互斥问题，只需把临界区置于 P(S) 和 V(S) 之间，即可实现两线程对临界资源的互斥访问。

### 临界资源与临界区

**同时仅允许一个进程使用的资源**称为为临界资源。

### 互斥的概念与要求

- 空闲让进
- 忙则等待
- 有限等待
- 让权等待。当一个进程因为某些原因不能进入临界区，应释放处理器给其他进程。

### 同步的概念与实现机制

进程同步，是指多个相互合作的进程在一些关键点上可能需要互相等待或交换信息，这种相互制约关系称为进程同步。

## 3.2、互斥实现方法

### 1.软件方法

#### 单标志法

```c
/* PROCESS 0 */
while(turn != 0);//wait
/* critical section */
turn = 1;//out
 
/* PROCESS 1 */
while(turn != 1);
/* critical section */
turn = 0;//out
```

特点：

`1）进入临界区之前先检查turn，如果等于进程号，就可以进入临界区，否则循环等待，因此可以实现互斥；`

`2）等待期间会耗费处理器时间；`

`3）两个进程交替使用处理器，执行速度取决于慢的进程；`

`4）如果一个终止（无论是在临界区内还是临界区外），另一个会被永远阻塞。`

此算法不能保证实现空闲让进原则。

#### 双标志先检查法

```c
/* PROCESS 0 */
while(flag[1]);//wait
flag[0] = true;//in
/* critical section */
flag[0] = false;//out
 
/* PROCESS 1 */
while(flag[0]);//wait
flag[1] = true;//in
/* critical section */
flag[1] = false;//out
```

特点：

`1）进入临界区之前先检查另一个进程的flag，直到该flag==false，然后设置本进程的flag置为true，接着进入临界区，出了临界区再把本进程的flag置为false；`

`2）如果一个进程出了临界区且置flag为false后终止，则另一个进程不会被阻塞；`

`3）如果一个进程在临界区内终止，或者在置flag为true且进入临界区之前终止，则另一个进程会永久阻塞；`

`4）两个进程还可能同时进入临界区，导致互斥失败。`

解决了空闲让进的问题，但是违背了忙则等待。

#### 双标志后检查法

```c
/* PROCESS 0 */
flag[0] = true;
while(flag[1]);//wait
/* critical section */
flag[0] = false;//exit
 
/* PROCESS 1 */
flag[1] = true;
while(flag[0]);//wait
/* critical section */
flag[1] = false;//exit
```

特点：

`1）进入临界区之前先把本进程的flag置为true；然后再检查另一个进程的flag，直到该flag==false，接着进入临界区，出了临界区再把本进程的flag置为false；`

`2）如果一个进程出了临界区且置flag为false后终止，则另一个进程不会被阻塞；`

`3）如果一个进程在临界区内终止，或者在置flag为true之后且进入临界区之前终止，则另一个进程会永久阻塞；`

`4）保证了互斥，但可能造成死锁。`

会违背有限等待的原则。

#### Peterson算法

```c
void P0(){
    while(true){
        flag[0] = true;
        turn = 1;
        while(flag[1] && turn==1);
        /* critical section */
        flag[0] = false;
    }
}
 
void P1(){
    while(true){
        flag[1] = true;
        turn = 0;
        while(flag[0] && turn==0);
        /* critical section */
        flag[1] = false;
    }
}
```

特点：

` 先置自己的flag为true，表明想要进入临界区的意愿，但是先礼让其他进程，主动把turn让给其他人——如果其他进程刚好想进入临界区，上门的好事不要白不要，赶紧跳出循环进入临界区；如果其他进程不想进入临界区，则跳过循环进入临界区，出了临界区置自己的flag为false。`

### 2.硬件方法

硬件方法主要两种：

1. 中断屏蔽
2. 硬件指令

硬件方法的优点：

- 适用范围广
- 简单
- 支持多个临界区

缺点：

- 等待进入临界区耗费时间
- 不能实现让权等待
- 可能导致饥饿

## 3.3、信号量

### 1.信号量及同步原语

P操作请求资源，V操作释放资源。

### 2.信号量的分类

- 整型信号量
- 记录型信号量（资源信号量）

### 3.信号量的应用

#### 实现进程同步

```c
semaphore N = 0;
P1()
{
    S1;
    V(N);
}
P2()
{
    P(N);
    S2;   
}
```

#### 实现进程互斥

```c
semaphore N = 0;
P1()
{
    P(N);
    S1;
    V(N);
}
P2()
{
    P(N);
    S2; 
    V(N);
}
```

### 4.经典同步问题

#### 1.生产者-消费者问题

```c
Semaphore full=0;//满缓冲池数目
Semaphore empty=n;//空缓冲池数目
Semaphore mutex=1;//对有界缓冲区进行操作的互斥信号量
Producer()
{
    while(true)
    {
        Produce an item and put in nextp;//nextp is buffer
        P(empty);//申请一个空换成池
        P(mutex);//申请使用缓冲池
		//将产品放入缓冲池
        V(mutex);
        V(full);
    }
}
Consumer()
{
    while(true)
    {
        Produce an item and put in nextp;//nextp is buffer
        P(full);
        P(mutex);
		//取出产品
        V(mutex);
        V(empty);
        Consumer the item in nextc;
    }
}
```

#### 2.读者-写者问题

读者优先算法

```c
int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
writer () {  //写者进程
    while (1){
        P(rw); // 互斥访问共享文件
        Writing;  //写入
        V(rw) ;  //释放共享文件
    }
}

reader () {  // 读者进程
    while(1){
        P (mutex) ;  //互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        reading;  //读取
        P (mutex) ;  //互斥访问count变量
        count--; //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw) ;  //允许写进程写
        V (mutex) ;  //释放互斥变量 count，允许其他读者读
    }
}
```

写进程优先

```c
int count = 0;  //用于记录当前的读者数量
semaphore mutex = 1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
semaphore w=1;  //用于实现“写优先”

writer(){
    while(1){
        P(w);  //在无写进程请求时进入
        P(rw);  //互斥访问共享文件
        writing;  //写入
        V(rw);  // 释放共享文件
        V(w) ;  //恢复对共享支件的访问
    }
}

reader () {  //读者进程
    while (1){
        P (w) ;  // 在无写进程请求时进入
        P (mutex);  // 互斥访问count变量

        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写

        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        V(w);  //恢复对共享文件的访问
        reading;  //读取
        P (mutex) ; //互斥访问count变量
        count--;  //读者计数器减1

        if (count==0)  //当最后一个读进程读完共享文件
            V(rw);  //允许写进程写

        V (mutex);  //释放互斥变量count
    }
}
```

公平情况算法（按照到达顺序进行操作）

```c
int count = 0;  //用于记录当前的读者数量
semaphore mutex = 1;  //用于保护更新count变量时的互斥
semaphore r=1;  //用于保证读者互斥地访问文件
semaphore w=1;  //用于保证写者互斥地访问

reader () {  //读者进程
    while (1){
        P (w) ;  // 在无写进程请求时进入
        P(r);//等别人读完
        if (count==0)  //当第一个读进程读共享文件时，阻止写者进入
            P(mutex); 
        count++;  //读者计数器加1
        V(r);  //恢复对共享文件的访问
        reading;  //读取
        P (r) ; //互斥访问count变量
        count--;  //读者计数器减1

        if (count==0)  //当最后一个读进程读完共享文件
            V(mutex);  //允许写进程写

        V (r);  //允许别人读
    }
}

writer(){
    while(1){
        P(w);  //在无写进程请求时进入
        P(mutex);
        writing;  //写入
        V(mutex);  // 释放共享文件
        V(w) ;  //恢复对共享支件的访问
    }
}

```

#### 3.哲学家进餐问题

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-140630144622230.jpg)

```c
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
Pi(){  //i号哲学家的进程
    do{
        P (chopstick[i] %5) ; //取左边筷子
        P (chopstick[(i+1) %5] ) ；  //取右边篌子
        eat;  //进餐
        V(chopstick[i] %5) ; //放回左边筷子
        V(chopstick[(i+l)%5]);  //放回右边筷子
        think;  //思考
    } while (1);
}
//可能会导致死锁
```

新的算法

```c
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
Pi(int i){  //i号哲学家的进程
    if(i%2!=0)
    {
        while(1)
        {
        P (chopstick[i] %5) ; //取左边筷子
        P (chopstick[(i+1) %5] ) ；  //取右边篌子
        eat;  //进餐
        V(chopstick[i] %5) ; //放回左边筷子
        V(chopstick[(i+l)%5]);  //放回右边筷子
        think;  //思考   
        }     
    }
    else
    {
        while(1)
        {        
        P (chopstick[(i+1) %5] ) ；  //取右边篌子
        P (chopstick[i] %5) ; //取左边筷子
        eat;  //进餐
        V(chopstick[i] %5) ; //放回左边筷子
        V(chopstick[(i+l)%5]);  //放回右边筷子
        think;  //思考
        }
    }
}
```

#### 4.理发师问题

```c
int chairs = n+1;//凳子和理发椅的数量
semaphore ready=0;//等待顾客的数量
semaphore finish=1;//理发师空闲
semaphore mutex=1;//互斥信号量
barber()
{
    while(1)
    {
        P(ready);//请求顾客
        haircut;
        P(mutex);//请求访问chairs
        chairs++;//顾客走掉
        V(mutex);//释放chairs
        V(finish);//理发师空闲
    }
}
consumer()
{
    while(1)
    {
        P(mutex);//请求访问chairs
        if(chairs>0)
        {
            chairs--;//占一个椅子
            V(mutex);//释放chairs
            V(ready);//等待顾客增加
            V(finish);//请求理发师
        }
        else
        {
            V(mutex);//释放chairs
        }
    }
}
```

#### 解题步骤分析

- 关系分析。
- 确定临界资源分析。
- 整理思路。

## 3.5、管程

基本特征：

- 局部于管程的数据只能被局部于管城内的过程所访问
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
- 每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程。



# 4、死锁

## 4.1、死锁的概念

 所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。很显然，如果没有外力的作用，那麽死锁涉及到的各个进程都将永远处于封锁状态。

## 4.2、死锁产生的原因和必要条件

### 1.资源分类

- 可剥夺资源
- 不可剥夺资源

对不可剥夺资源的竞争会产生死锁

### 2.死锁产生的原因

原因是竞争资源。

当系统中有多个进程并发执行时，若系统的资源不足以同时满足所有进程的需要，则会引起进程对资源的竞争。

### 3.死锁产生的必要条件

- 互斥条件

指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完后释放资源。

- 不剥夺条件

指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

- 请求与保持条件

指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但它不会释放自己已经占有的资源。

`满足以上三个条件可能会产生死锁，但如果只有这三个条件，则不一定产生死锁。对死锁的产生，还需要第四个条件`

- 环路等待条件

存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源

## 4.3、处理死锁的基本方法

- 鸵鸟算法。不理睬死锁
- 预防死锁。破坏死锁产生的一个或多个条件
- 避免死锁
- 检测及接触死锁

## 4.4、死锁的预防

### 1.互斥条件

允许多个进程同时访问资源。不大可能的

### 2.不剥夺条件

对于已经获得资源的进程，需要新的资源之前需要释放所有已经获得的资源，再重新申请。但是不适合用于剥夺资源后代价比较大的场合。

### 3.请求与保持条件

可以采用预先静态分配方法。资源不满足时就不运行，等资源到齐再运行。

必须事先知道作业的全部资源，会导致系统的资源不能充分利用。

### 4.环路等待条件

可以采用有序资源分配法。

所有资源按类型分配序号，每个进程严格按照序号递增的次序请求资源，同类资源一次申请完。

## 4.5、死锁的避免

### 1.安全状态与不安全状态

系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。

系统进入不安全状态，可能进入死锁状态；只要系统在安全状态则不会产生死锁

### 2.银行家算法

<img src="https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20200911232356062.png" alt="image-20200911232356062" style="zoom:80%;" />

## 4.6、死锁的检测和解除

### 1.死锁检测

#### 资源分配图

![image-20200911233522530](../../AppData/Roaming/Typora/typora-user-images/image-20200911233522530.png)

用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。

#### 死锁定理

可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：

1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图(b)所示的情况。

2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图中，进程P2就满足这样的条件。根据第1) 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图(c)所示。

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/1-1406301JP45A.jpg)

### 2.死锁检测算法

### 3.死锁解除

- 剥夺资源
- 撤销进程
- 进程回退

## 4.7、死锁与饿死

当等待事件给进程推进和响应带来明显影响时，称此时发生了**进程饥饿**。

饥饿到一定程度，进程所赋予的任务即使完成也不再具有意义时，称该进程为**饿死**。

忙时等待条件下发生的饥饿，称为**活锁**。

### 饿死与死锁的区别

- 从进程状态考虑，死锁进程都处于等待；忙时等待的进程不都处于等待状态，却可能饿死。
- 死锁进程等待的是永远不会释放的资源；饿死进程等待的是可以释放但是等待时间没有上界。
- 死锁一定发生了循环等待，饿死不一定。可以检测到死锁，不能检测是否有进程饿死。
- 死锁一定设计到多进程，饥饿和饿死的进程可能只有一个。



# 5、错题

- 终端扫描机构是<u>每条指令执行周期内最后时刻</u>扫描一次中断寄存器。
- FCFS有利于CPU繁忙型的作业，不利于I/O繁忙型的作业
- 所谓临界区是一段程序
- SJF平均周转时间最短
- 信号量为0标识资源分配完，信号量为负值，绝对值即等待的进程数
- 