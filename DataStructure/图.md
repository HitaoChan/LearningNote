# 0、图的分类

## 0.1、完全图

> 任意两个点都有边

## 0.2、连通、连通图、连通分量

> 范围：无向图
>
> 连通：两点有路径
>
> 连通图：任意两点都连通
>
> 连通分量：不构成连通图的成为连通分量

## 0.3、强连通图、强连通分量

> 范围：有向图
>
> 连通：两点有路径
>
> 强连通图：每对顶点vi到vj，vj到vi都有路径
>
> 强连通分量：不构成强连通图的成为强连通分量

# 1、最短路径

## 1.1、迪杰斯特拉算法

> 算法特点：使用广度优先
>
> 时间复杂度：O(n^2)
>
> 组成：dist[]数组表示、path[]数组、set[]数组、g [] [] 数组表示邻接矩阵

伪代码：

```c++
//以i为中间点
//从剩余顶点取一个j
if dist[j] >dist[i]+g[i][任意点]=x
{
    dist[j]=x;
    path[j]=i;
}

```

![img](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/2012073019540660.gif)

## 1.2、弗洛伊德算法

> 时间复杂度：O(n^3)
>
> 算法特点：处理有向图



# 2、拓扑排序（AOV）

> 特点：有向  无环图
>
> 作用：判断有无环
>
> 思路：从入度为0的顶点开始去除他的所有边，重复这个过程。



# 3、图的遍历

## 3.1、DFS（深度优先）

> 作用：判断有无环
>
> 生成：深度优先搜索树
>
> 算法时间复杂度：
>
> 1. 邻接矩阵：O(n^2)
> 2. 邻接表：O(n+e)

## 3.2、BFS（广度优先）

> 作用：无权图，找到离源点最近的
>
> 生成：广度优先搜索树
>
> 算法时间复杂度：
>
> 1. 邻接矩阵：O(n^2)
> 2. 邻接表：O(n+e)

# 4、关键路径（AOE）



# 5、最小生成树

## 5.1、普利姆算法（Prim）

> 思路：可以看作加点法
>
> 1. 图的所有顶点集合为V；初始令集合u={s},v=V−u
> 2. 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)加入到最小生成树中，并把v0并入到集合u中。
> 3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

![Prim算法](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/20160714161107576)

## 5.2、克鲁斯卡尔算法（Kruskal）

> 思路：可以看作加边法
>
> 1. 把图中的所有边按代价从小到大排序；
>
> 2. 把图中的n个顶点看成独立的n棵树组成的森林；
>
> 3. 按权值从小到大选择边，所选的边连接的两个顶点ui , vi应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
>
> 4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

![克鲁斯卡尔算法](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/20160714144315409)



# 6、图的存储结构

## 6.1、邻接矩阵

## 6.2、邻接表



# 7、杂

## 7.1、 简单路径

> 定义：一条路径上不能有相同顶点。
>
> 考题：回路不是简单路径。

## 7.2、回路

> 定义：第一个顶点和最后一个顶点相同的路径。
>
> 例如：
>
> ![img](https://bkimg.cdn.bcebos.com/formula/8398d5bc646ebb13c7c271649833afc8.svg)
>
> ![图1](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/472309f790529822e0f8ad28dcca7bcb0b46d416)
>
> 别称：环

## 7.3、简单回路

> 定义：第一个和最后一个顶点相同，其他都不相同的回路。