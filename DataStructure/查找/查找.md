## 顺序查找

**基本思想：**顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

**复杂度分析：**　

查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;
当查找不成功时，需要n+1次比较，时间复杂度为O(n);

所以，**顺序查找的时间复杂度为O(n)**

## 折半查找

**基本思想：**也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

**复杂度分析：**最坏情况下，关键词比较次数为log2(n+1)，且**期望时间复杂度为O(log2n)**；

## 分块查找

把线性表分成若干块，块中的存储顺序是任意的，但是块与块之间的关键字必须按照大小有序排列。

又叫索引表查找，建立一个索引表数组，将一块中的最大值的值作为索引的值。

查找方法为第一次在索引表中二分查找，第二次在low和high中顺序查找

# 二叉排序树与平衡二叉树

## 二叉排序数

**性质**

- 左子树所有关键字的值均不大于（或小于）根关键字的值
- 右子树所有关键字的值均不小于（或大于）根关键字的值
- 左右子树也是排序二叉树

### **删除关键字**

假设在二叉排序树上被删除结点为p，f为其双亲结点

情况有三种

- p结点为叶子结点。直接删除即可
- p结点只有右子树而无左子树，或者只有左子树而无右子树。此时只需将p删掉，然后将p的子树直接连接在原来p与其双亲结点f相连的指针上即可。
- p结点既有左子树又有右子树。可以将此情况转换为情况1或情况2。将p的左子树最右的结点的值替换p然后删除最右结点（或将p右子树最左边的结点的值替换然后删除最左结点）。

## 平衡二叉树

**概念**

- 左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1
- 一个结点的`平衡因子是他的左子树的高度减去右子树的高度，只有-1、0、1三个值。`

**建立**

- 每插入一个关键字都要检验二叉树的平衡

**平衡调整**

- LR调整。
- LL调整。
- RL调整。
- RR调整。

**删除节点**

**平衡调整过程总结**

要根据插入结点的状态知道是那个调整，将插入状态和调整方法结合起来记忆。

# B-树的基本概念及其基本操作

**概念**

1. 若根结点不是终端节点，则至少有两棵子树，最多有m棵子树。
2. 除根结点外的所有非叶结点至少有⌈m/2⌉棵子树，最多有m棵子树。
3. 所有的非叶结点都出现在同一层次上，并且不带信息（可视为失败结点）。
4. 所有非叶结点的结构如下：

![image-20201112101439248](https://gitee.com/HaitoChan/upload-pic-typora/raw/master/null/image-20201112101439248.png)

> a)、Pi-1所指子树中所有结点的关键字均小于Ki
> b)、Pi所指子树中所有结点的关键字均大于Ki

# B+树的基本概念

**概念**

1. 每个分支结点最多有m棵子树。
2. 非叶根结点至少有两棵子树,其他每个分支结点至少有⌈m/2⌉棵子树。
3. 结点的子树个数与关键字个数相等。
4. 所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键字按大小顺序排列,并且相邻叶结点按大小顺序相互链接起来。
5. 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。

# 散列表

**概念**

H(Key)为key的地址

`装填因子a=n/m`，a越小冲突概率越小

**Hash函数构造方法**

- 保留余数法。H(key)=key mod p。p为不大于表长最大素数。

**冲突处理方法**

- `堆积问题不可避免`
- 线性探查法，遇到冲突对地址+1探查下面空闲的位置
- 平方探查法，跟线性探查相似，不过不是+1是+1的平方、-1的平方、+2的平方、-2的平方
- 链地址法，Hash表中每个单元中存放的不再是记录本身，二是相应同义词单链表的表头指针。